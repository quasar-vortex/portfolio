"use server";
import z from "zod";

/* 
const twilioConfig = {
  key: process.env.TWILIO_SECRET_KEY,
  keyId: process.env.TWILIO_KEY_ID,
  number: process.env.TWILIO_NUMBER,
  personalNum: process.env.PERSONAL_NUMBER,
  accountId: process.env.TWILIO_ACCOUNT_ID,
};
*/
const formUrl = "https://formspree.io/f/mdkgvkrz";
const contactSchema = z.object({
  firstName: z
    .string()
    .min(2, "First name must be at least 2 characters.")
    .max(20, "First name cannot exceed 20 characters."),
  lastName: z
    .string()
    .min(2, "Last name must be at least 2 characters.")
    .max(20, "Last name cannot exceed 20 characters."),
  phone: z
    .string()
    .regex(/\d/g)
    .length(10, { message: "Phone number must be 10 digits in length." }),
  email: z.string().email({ message: "Must enter a valid email address." }),
  message: z
    .string()
    .min(20, { message: "Message must be at least 20 characters long." })
    .max(500, { message: "Message cannot exceed 500 characters." }),
});

//@ts-expect-error previous state in form send message
export const sendMessage = async (prevState, data: FormData) => {
  /* 
  const t = twilio(twilioConfig.keyId, twilioConfig.key, {
    accountSid: twilioConfig.accountId,
  });
*/

  const formData = Object.fromEntries(data);
  try {
    await contactSchema.parseAsync(formData);
    /* 
    const res = await t.messages.create({
      to: twilioConfig.personalNum!,
      from: twilioConfig.number,
      body: `Name: ${formData.firstName} ${formData.lastName}\nPhone: ${formData.phone}\nEmail: ${formData.email}\nMessage: ${formData.message}`,
    });
    const json = res.toJSON();
    console.log(json);
*/
    const res = await fetch(formUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(formData),
    });
    if (res.ok) return { message: "Message Sent Successfully" };

    throw new Error("Something Went Wrong");
  } catch (error) {
    console.log(error);
    if (error instanceof z.ZodError) {
      return {
        error: JSON.stringify(error.issues),
      };
    }
    return { error: "Something went wrong. Please try again later." };
  }
};
import { useEffect, useState } from "react";

function useDebouncedValue<T>(value: T, delay: number): T {
  const [debounced, setDebounced] = useState(value);

  useEffect(() => {
    const timer = setTimeout(() => setDebounced(value), delay);
    return () => clearTimeout(timer);
  }, [value, delay]);

  return debounced;
}
export default useDebouncedValue;
import { createStore } from "zustand";
import { persist } from "zustand/middleware";
export type User = {
  email: string;
  firstName: string;
  lastName: string;
  id: string;
  role: "ADMIN" | "USER";
  bio: string | null;
  avatarFile: {
    id: string;
    url: string;
  } | null;
};
export type AuthState = {
  user: User | null;
  accessToken: string | null;
  createdAt: number | null;
};
type AuthActions = {
  setUser: (p: AuthState) => void;
  clearUser: () => void;
};
export type LoginResponse = { user: User; accessToken: string };
export type AuthStoreState = AuthActions & AuthState;
export const initAuthStore = (): AuthState => {
  return {
    user: null,
    accessToken: null,
    createdAt: null,
  };
};
export const defaultInitState: AuthState = {
  user: null,
  accessToken: null,
  createdAt: null,
};

export const createAuthStore = (initState: AuthState = defaultInitState) => {
  return createStore<AuthStoreState>()(
    persist(
      (set) => ({
        ...initState,
        setUser: (p) => {
          set((st) => ({
            ...st,
            user: p.user,
            accessToken: p.accessToken,
            createdAt: Date.now(),
          }));
        },
        clearUser: () =>
          set((st) => ({
            ...st,
            user: null,
            accessToken: null,
            createdAt: null,
          })),
      }),
      {
        name: "auth",
        partialize: (st) => ({
          user: st.user,
          accessToken: st.accessToken,
          createdAt: st.createdAt,
        }),
        onRehydrateStorage: (st) => {
          const currentTime = Date.now();
          const createdAt = st?.createdAt ?? 0;
          if (createdAt) {
            if (
              currentTime - (createdAt as unknown as number) >
              1000 * 14 * 60 // 14 minutes
            ) {
              st?.clearUser?.();
            }
          }
        },
      }
    )
  );
};

export let authStoreRef: ReturnType<typeof createAuthStore> | null = null;

export const setAuthStoreRef = (store: ReturnType<typeof createAuthStore>) => {
  authStoreRef = store;
};
import { isServer, QueryClient } from "@tanstack/react-query";

function makeQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 60 * 1000,
      },
    },
  });
}

let browserQueryClient: QueryClient | undefined = undefined;

export function getQueryClient() {
  if (isServer) {
    return makeQueryClient();
  } else {
    if (!browserQueryClient) browserQueryClient = makeQueryClient();
    return browserQueryClient;
  }
}
